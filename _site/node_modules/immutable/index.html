
<!doctype html>














<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/assets/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/assets/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/assets/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Jekyll, NexT" />





  <link rel="alternate" href="/atom.xml" title="Yueran's Learning" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?v=5.1.1" />
















<meta name="description" content="# Immutable collections for JavaScript [![Build Status](https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml?query=branch%3Amain) [Chat on slack](https://immutable-js.slack.com) [Read the docs](https://immutable-js.com) and eat your vegetables. Docs are automatically generated from [README.md][] and [immutable.d.ts][]. Please contribute! Also, don&apos;t miss the [wiki][] which contains articles on additional specific topics. Can&apos;t find something? Open an [issue][]. **Table of contents:** - [Introduction](#introduction) - [Getting started](#getting-started) - [The case for Immutability](#the-case-for-immutability) - [JavaScript-first API](#javaScript-first-api) - [Nested Structures](#nested-structures) - [Equality treats Collections as Values](#equality-treats-collections-as-values) - [Batching Mutations](#batching-mutations) - [Lazy Seq](#lazy-seq) - [Additional Tools and Resources](#additional-tools-and-resources) - [Contributing](#contributing) ## Introduction [Immutable][] data cannot be changed once created, leading to much simpler application development, no defensive copying, and enabling advanced memoization and change detection techniques with simple logic. [Persistent][] data presents a mutative API which does not update the data in-place, but instead always yields new updated data. Immutable.js provides many Persistent Immutable data structures including: `List`, `Stack`, `Map`, `OrderedMap`, `Set`, `OrderedSet` and `Record`. These data structures are highly efficient on modern JavaScript VMs by using structural sharing via [hash maps tries][] and [vector tries][] as popularized by Clojure and Scala, minimizing the need to copy or cache data. Immutable.js also provides a lazy `Seq`, allowing efficient chaining of collection methods like `map` and `filter` without creating intermediate representations. Create some `Seq` with `Range` and `Repeat`. Want to hear more? Watch the presentation about Immutable.js: [![Immutable Data and React](website/public/Immutable-Data-and-React-YouTube.png)](https://youtu.be/I7IdS-PbEgI) [README.md]: https://github.com/immutable-js/immutable-js/blob/main/README.md [immutable.d.ts]: https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts [wiki]: https://github.com/immutable-js/immutable-js/wiki [issue]: https://github.com/immutable-js/immutable-js/issues [Persistent]: https://en.wikipedia.org/wiki/Persistent_data_structure [Immutable]: https://en.wikipedia.org/wiki/Immutable_object [hash maps tries]: https://en.wikipedia.org/wiki/Hash_array_mapped_trie [vector tries]: https://hypirion.com/musings/understanding-persistent-vector-pt-1 ## Getting started Install `immutable` using npm. ```shell npm install immutable ``` Or install using yarn. ```shell yarn add immutable ``` Then require it into any module. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;) + &apos; vs. &apos; + map2.get(&apos;b&apos;); // 2 vs. 50 ``` ### Browser Immutable.js has no dependencies, which makes it predictable to include in a Browser. It&apos;s highly recommended to use a module bundler like [webpack](https://webpack.github.io/), [rollup](https://rollupjs.org/), or [browserify](https://browserify.org/). The `immutable` npm module works without any additional consideration. All examples throughout the documentation will assume use of this kind of tool. Alternatively, Immutable.js may be directly included as a script tag. Download or link to a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable) or [jsDelivr](https://www.jsdelivr.com/package/npm/immutable). Use a script tag to directly add `Immutable` to the global scope: ```html ``` Or use an AMD-style loader (such as [RequireJS](https://requirejs.org/)): ```js require([&apos;./immutable.min.js&apos;], function (Immutable) { var map1 = Immutable.Map({ a: 1, b: 2, c: 3 }); var map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;); // 2 map2.get(&apos;b&apos;); // 50 }); ``` ### Flow &amp; TypeScript Use these Immutable collections and sequences as you would use native collections in your [Flowtype](https://flowtype.org/) or [TypeScript](https://typescriptlang.org) programs while still taking advantage of type generics, error detection, and auto-complete in your IDE. Installing `immutable` via npm brings with it type definitions for Flow (v0.55.0 or higher) and TypeScript (v2.1.0 or higher), so you shouldn&apos;t need to do anything at all! #### Using TypeScript with Immutable.js v4 Immutable.js type definitions embrace ES2015. While Immutable.js itself supports legacy browsers and environments, its type definitions require TypeScript&apos;s 2015 lib. Include either `&quot;target&quot;: &quot;es2015&quot;` or `&quot;lib&quot;: &quot;es2015&quot;` in your `tsconfig.json`, or provide `--target es2015` or `--lib es2015` to the `tsc` command. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;) + &apos; vs. &apos; + map2.get(&apos;b&apos;); // 2 vs. 50 ``` #### Using TypeScript with Immutable.js v3 and earlier: Previous versions of Immutable.js include a reference file which you can include via relative path to the type definitions at the top of your file. ```js /// import Immutable from &apos;immutable&apos;; var map1: Immutable.Map; map1 = Immutable.Map({ a: 1, b: 2, c: 3 }); var map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;); // 2 map2.get(&apos;b&apos;); // 50 ``` ## The case for Immutability Much of what makes application development difficult is tracking mutation and maintaining state. Developing with immutable data encourages you to think differently about how data flows through your application. Subscribing to data events throughout your application creates a huge overhead of book-keeping which can hurt performance, sometimes dramatically, and creates opportunities for areas of your application to get out of sync with each other due to easy to make programmer error. Since immutable data never changes, subscribing to changes throughout the model is a dead-end and new data can only ever be passed from above. This model of data flow aligns well with the architecture of [React][] and especially well with an application designed using the ideas of [Flux][]. When data is passed from above rather than being subscribed to, and you&apos;re only interested in doing work when something has changed, you can use equality. Immutable collections should be treated as _values_ rather than _objects_. While objects represent some thing which could change over time, a value represents the state of that thing at a particular instance of time. This principle is most important to understanding the appropriate use of immutable data. In order to treat Immutable.js collections as values, it&apos;s important to use the `Immutable.is()` function or `.equals()` method to determine _value equality_ instead of the `===` operator which determines object _reference identity_. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); map1.equals(map2); // true map1 === map2; // false ``` Note: As a performance optimization Immutable.js attempts to return the existing collection when an operation would result in an identical collection, allowing for using `===` reference equality to determine if something definitely has not changed. This can be extremely useful when used within a memoization function which would prefer to re-run the function if a deeper equality check could potentially be more costly. The `===` equality check is also used internally by `Immutable.is` and `.equals()` as a performance optimization. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 2); // Set to same value map1 === map2; // true ``` If an object is immutable, it can be &quot;copied&quot; simply by making another reference to it instead of copying the entire object. Because a reference is much smaller than the object itself, this results in memory savings and a potential boost in execution speed for programs which rely on copies (such as an undo-stack). ```js const { Map } = require(&apos;immutable&apos;); const map = Map({ a: 1, b: 2, c: 3 }); const mapCopy = map; // Look, &quot;copies&quot; are free! ``` [React]: https://reactjs.org/ [Flux]: https://facebook.github.io/flux/docs/in-depth-overview/ ## JavaScript-first API While Immutable.js is inspired by Clojure, Scala, Haskell and other functional programming environments, it&apos;s designed to bring these powerful concepts to JavaScript, and therefore has an Object-Oriented API that closely mirrors that of [ES2015][] [Array][], [Map][], and [Set][]. [es2015]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla [array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array [map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map [set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set The difference for the immutable collections is that methods which would mutate the collection, like `push`, `set`, `unshift` or `splice`, instead return a new immutable collection. Methods which return new arrays, like `slice` or `concat`, instead return new immutable collections. ```js const { List } = require(&apos;immutable&apos;); const list1 = List([1, 2]); const list2 = list1.push(3, 4, 5); const list3 = list2.unshift(0); const list4 = list1.concat(list2, list3); assert.equal(list1.size, 2); assert.equal(list2.size, 5); assert.equal(list3.size, 6); assert.equal(list4.size, 13); assert.equal(list4.get(0), 1); ``` Almost all of the methods on [Array][] will be found in similar form on `Immutable.List`, those of [Map][] found on `Immutable.Map`, and those of [Set][] found on `Immutable.Set`, including collection operations like `forEach()` and `map()`. ```js const { Map } = require(&apos;immutable&apos;); const alpha = Map({ a: 1, b: 2, c: 3, d: 4 }); alpha.map((v, k) =&amp;gt; k.toUpperCase()).join(); // &apos;A,B,C,D&apos; ``` ### Convert from raw JavaScript objects and arrays. Designed to inter-operate with your existing JavaScript, Immutable.js accepts plain JavaScript Arrays and Objects anywhere a method expects a `Collection`. ```js const { Map, List } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3, d: 4 }); const map2 = Map({ c: 10, a: 20, t: 30 }); const obj = { d: 100, o: 200, g: 300 }; const map3 = map1.merge(map2, obj); // Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 } const list1 = List([1, 2, 3]); const list2 = List([4, 5, 6]); const array = [7, 8, 9]; const list3 = list1.concat(list2, array); // List [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] ``` This is possible because Immutable.js can treat any JavaScript Array or Object as a Collection. You can take advantage of this in order to get sophisticated collection methods on JavaScript Objects, which otherwise have a very sparse native API. Because Seq evaluates lazily and does not cache intermediate results, these operations can be extremely efficient. ```js const { Seq } = require(&apos;immutable&apos;); const myObject = { a: 1, b: 2, c: 3 }; Seq(myObject) .map(x =&amp;gt; x * x) .toObject(); // { a: 1, b: 4, c: 9 } ``` Keep in mind, when using JS objects to construct Immutable Maps, that JavaScript Object properties are always strings, even if written in a quote-less shorthand, while Immutable Maps accept keys of any type. ```js const { fromJS } = require(&apos;immutable&apos;); const obj = { 1: &apos;one&apos; }; console.log(Object.keys(obj)); // [ &quot;1&quot; ] console.log(obj[&apos;1&apos;], obj[1]); // &quot;one&quot;, &quot;one&quot; const map = fromJS(obj); console.log(map.get(&apos;1&apos;), map.get(1)); // &quot;one&quot;, undefined ``` Property access for JavaScript Objects first converts the key to a string, but since Immutable Map keys can be of any type the argument to `get()` is not altered. ### Converts back to raw JavaScript objects. All Immutable.js Collections can be converted to plain JavaScript Arrays and Objects shallowly with `toArray()` and `toObject()` or deeply with `toJS()`. All Immutable Collections also implement `toJSON()` allowing them to be passed to `JSON.stringify` directly. They also respect the custom `toJSON()` methods of nested objects. ```js const { Map, List } = require(&apos;immutable&apos;); const deep = Map({ a: 1, b: 2, c: List([3, 4, 5]) }); console.log(deep.toObject()); // { a: 1, b: 2, c: List [ 3, 4, 5 ] } console.log(deep.toArray()); // [ 1, 2, List [ 3, 4, 5 ] ] console.log(deep.toJS()); // { a: 1, b: 2, c: [ 3, 4, 5 ] } JSON.stringify(deep); // &apos;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[3,4,5]}&apos; ``` ### Embraces ES2015 Immutable.js supports all JavaScript environments, including legacy browsers (even IE11). However it also takes advantage of features added to JavaScript in [ES2015][], the latest standard version of JavaScript, including [Iterators][], [Arrow Functions][], [Classes][], and [Modules][]. It&apos;s inspired by the native [Map][] and [Set][] collections added to ES2015. All examples in the Documentation are presented in ES2015. To run in all browsers, they need to be translated to ES5. ```js // ES2015 const mapped = foo.map(x =&amp;gt; x * x); // ES5 var mapped = foo.map(function (x) { return x * x; }); ``` All Immutable.js collections are [Iterable][iterators], which allows them to be used anywhere an Iterable is expected, such as when spreading into an Array. ```js const { List } = require(&apos;immutable&apos;); const aList = List([1, 2, 3]); const anArray = [0, ...aList, 4, 5]; // [ 0, 1, 2, 3, 4, 5 ] ``` Note: A Collection is always iterated in the same order, however that order may not always be well defined, as is the case for the `Map` and `Set`. [Iterators]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol [Arrow Functions]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions [Classes]: https://wiki.ecmascript.org/doku.php?id=strawman:maximally_minimal_classes [Modules]: https://www.2ality.com/2014/09/es6-modules-final.html ## Nested Structures The collections in Immutable.js are intended to be nested, allowing for deep trees of data, similar to JSON. ```js const { fromJS } = require(&apos;immutable&apos;); const nested = fromJS({ a: { b: { c: [3, 4, 5] } } }); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } } ``` A few power-tools allow for reading and operating on nested data. The most useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`, `Map` and `OrderedMap`. ```js const { fromJS } = require(&apos;immutable&apos;); const nested = fromJS({ a: { b: { c: [3, 4, 5] } } }); const nested2 = nested.mergeDeep({ a: { b: { d: 6 } } }); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } } console.log(nested2.getIn([&apos;a&apos;, &apos;b&apos;, &apos;d&apos;])); // 6 const nested3 = nested2.updateIn([&apos;a&apos;, &apos;b&apos;, &apos;d&apos;], value =&amp;gt; value + 1); console.log(nested3); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } } const nested4 = nested3.updateIn([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], list =&amp;gt; list.push(6)); // Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } } ``` ## Equality treats Collections as Values Immutable.js collections are treated as pure data _values_. Two immutable collections are considered _value equal_ (via `.equals()` or `is()`) if they represent the same collection of values. This differs from JavaScript&apos;s typical _reference equal_ (via `===` or `==`) for Objects and Arrays which only determines if two variables represent references to the same object instance. Consider the example below where two identical `Map` instances are not _reference equal_ but are _value equal_. ```js // First consider: const obj1 = { a: 1, b: 2, c: 3 }; const obj2 = { a: 1, b: 2, c: 3 }; obj1 !== obj2; // two different instances are always not equal with === const { Map, is } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); map1 !== map2; // two different instances are not reference-equal map1.equals(map2); // but are value-equal if they have the same values is(map1, map2); // alternatively can use the is() function ``` Value equality allows Immutable.js collections to be used as keys in Maps or values in Sets, and retrieved with different but equivalent collections: ```js const { Map, Set } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); const set = Set().add(map1); set.has(map2); // true because these are value-equal ``` Note: `is()` uses the same measure of equality as [Object.is][] for scalar strings and numbers, but uses value equality for Immutable collections, determining if both are immutable and all keys and values are equal using the same measure of equality. [object.is]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is #### Performance tradeoffs While value equality is useful in many circumstances, it has different performance characteristics than reference equality. Understanding these tradeoffs may help you decide which to use in each case, especially when used to memoize some operation. When comparing two collections, value equality may require considering every item in each collection, on an `O(N)` time complexity. For large collections of values, this could become a costly operation. Though if the two are not equal and hardly similar, the inequality is determined very quickly. In contrast, when comparing two collections with reference equality, only the initial references to memory need to be compared which is not based on the size of the collections, which has an `O(1)` time complexity. Checking reference equality is always very fast, however just because two collections are not reference-equal does not rule out the possibility that they may be value-equal. #### Return self on no-op optimization When possible, Immutable.js avoids creating new objects for updates where no change in _value_ occurred, to allow for efficient _reference equality_ checking to quickly determine if no change occurred. ```js const { Map } = require(&apos;immutable&apos;); const originalMap = Map({ a: 1, b: 2, c: 3 }); const updatedMap = originalMap.set(&apos;b&apos;, 2); updatedMap === originalMap; // No-op .set() returned the original reference. ``` However updates which do result in a change will return a new reference. Each of these operations occur independently, so two similar updates will not return the same reference: ```js const { Map } = require(&apos;immutable&apos;); const originalMap = Map({ a: 1, b: 2, c: 3 }); const updatedMap = originalMap.set(&apos;b&apos;, 1000); // New instance, leaving the original immutable. updatedMap !== originalMap; const anotherUpdatedMap = originalMap.set(&apos;b&apos;, 1000); // Despite both the results of the same operation, each created a new reference. anotherUpdatedMap !== updatedMap; // However the two are value equal. anotherUpdatedMap.equals(updatedMap); ``` ## Batching Mutations &amp;gt; If a tree falls in the woods, does it make a sound? &amp;gt; &amp;gt; If a pure function mutates some local data in order to produce an immutable &amp;gt; return value, is that ok? &amp;gt; &amp;gt; — Rich Hickey, Clojure Applying a mutation to create a new immutable object results in some overhead, which can add up to a minor performance penalty. If you need to apply a series of mutations locally before returning, Immutable.js gives you the ability to create a temporary mutable (transient) copy of a collection and apply a batch of mutations in a performant manner by using `withMutations`. In fact, this is exactly how Immutable.js applies complex mutations itself. As an example, building `list2` results in the creation of 1, not 3, new immutable Lists. ```js const { List } = require(&apos;immutable&apos;); const list1 = List([1, 2, 3]); const list2 = list1.withMutations(function (list) { list.push(4).push(5).push(6); }); assert.equal(list1.size, 3); assert.equal(list2.size, 6); ``` Note: Immutable.js also provides `asMutable` and `asImmutable`, but only encourages their use when `withMutations` will not suffice. Use caution to not return a mutable copy, which could result in undesired behavior. _Important!_: Only a select few methods can be used in `withMutations` including `set`, `push` and `pop`. These methods can be applied directly against a persistent data-structure where other methods like `map`, `filter`, `sort`, and `splice` will always return new immutable data-structures and never mutate a mutable collection. ## Lazy Seq `Seq` describes a lazy operation, allowing them to efficiently chain use of all the higher-order collection methods (such as `map` and `filter`) by not creating intermediate collections. **Seq is immutable** — Once a Seq is created, it cannot be changed, appended to, rearranged or otherwise modified. Instead, any mutative method called on a `Seq` will return a new `Seq`. **Seq is lazy** — `Seq` does as little work as necessary to respond to any method call. Values are often created during iteration, including implicit iteration when reducing or converting to a concrete data structure such as a `List` or JavaScript `Array`. For example, the following performs no work, because the resulting `Seq`&apos;s values are never iterated: ```js const { Seq } = require(&apos;immutable&apos;); const oddSquares = Seq([1, 2, 3, 4, 5, 6, 7, 8]) .filter(x =&amp;gt; x % 2 !== 0) .map(x =&amp;gt; x * x); ``` Once the `Seq` is used, it performs only the work necessary. In this example, no intermediate arrays are ever created, filter is called three times, and map is only called once: ```js oddSquares.get(1); // 9 ``` Any collection can be converted to a lazy Seq with `Seq()`. ```js const { Map, Seq } = require(&apos;immutable&apos;); const map = Map({ a: 1, b: 2, c: 3 }); const lazySeq = Seq(map); ``` `Seq` allows for the efficient chaining of operations, allowing for the expression of logic that can otherwise be very tedious: ```js lazySeq .flip() .map(key =&amp;gt; key.toUpperCase()) .flip(); // Seq { A: 1, B: 2, C: 3 } ``` As well as expressing logic that would otherwise seem memory or time limited, for example `Range` is a special kind of Lazy sequence. ```js const { Range } = require(&apos;immutable&apos;); Range(1, Infinity) .skip(1000) .map(n =&amp;gt; -n) .filter(n =&amp;gt; n % 2 === 0) .take(2) .reduce((r, n) =&amp;gt; r * n, 1); // 1006008 ``` ## Additional Tools and Resources - [Atom-store](https://github.com/jameshopkins/atom-store/) - A Clojure-inspired atom implementation in Javascript with configurability for external persistance. - [Chai Immutable](https://github.com/astorije/chai-immutable) - If you are using the [Chai Assertion Library](https://chaijs.com/), this provides a set of assertions to use against Immutable.js collections. - [Fantasy-land](https://github.com/fantasyland/fantasy-land) - Specification for interoperability of common algebraic structures in JavaScript. - [Immutagen](https://github.com/pelotom/immutagen) - A library for simulating immutable generators in JavaScript. - [Immutable-cursor](https://github.com/redbadger/immutable-cursor) - Immutable cursors incorporating the Immutable.js interface over Clojure-inspired atom. - [Immutable-ext](https://github.com/DrBoolean/immutable-ext) - Fantasyland extensions for immutablejs - [Immutable-js-tools](https://github.com/madeinfree/immutable-js-tools) - Util tools for immutable.js - [Immutable-Redux](https://github.com/gajus/redux-immutable) - redux-immutable is used to create an equivalent function of Redux combineReducers that works with Immutable.js state. - [Immutable-Treeutils](https://github.com/lukasbuenger/immutable-treeutils) - Functional tree traversal helpers for ImmutableJS data structures. - [Irecord](https://github.com/ericelliott/irecord) - An immutable store that exposes an RxJS observable. Great for React. - [Mudash](https://github.com/brianneisler/mudash) - Lodash wrapper providing Immutable.JS support. - [React-Immutable-PropTypes](https://github.com/HurricaneJames/react-immutable-proptypes) - PropType validators that work with Immutable.js. - [Redux-Immutablejs](https://github.com/indexiatech/redux-immutablejs) - Redux Immutable facilities. - [Rxstate](https://github.com/yamalight/rxstate) - Simple opinionated state management library based on RxJS and Immutable.js. - [Transit-Immutable-js](https://github.com/glenjamin/transit-immutable-js) - Transit serialisation for Immutable.js. - See also: [Transit-js](https://github.com/cognitect/transit-js) Have an additional tool designed to work with Immutable.js? Submit a PR to add it to this list in alphabetical order. ## Contributing Use [Github issues](https://github.com/immutable-js/immutable-js/issues) for requests. We actively welcome pull requests, learn how to [contribute](https://github.com/immutable-js/immutable-js/blob/main/.github/CONTRIBUTING.md). Immutable.js is maintained within the [Contributor Covenant&apos;s Code of Conduct](https://www.contributor-covenant.org/version/2/0/code_of_conduct/). ### Changelog Changes are tracked as [Github releases](https://github.com/immutable-js/immutable-js/releases). ### License Immutable.js is [MIT-licensed](/node_modules/immutable/LICENSE). ### Thanks [Phil Bagwell](https://www.youtube.com/watch?v=K2NYwP90bNs), for his inspiration and research in persistent data structures. [Hugh Jackson](https://github.com/hughfdjackson/), for providing the npm package name. If you&apos;re looking for his unsupported package, see [this repository](https://github.com/hughfdjackson/immutable).">
<meta name="keywords" content="Jekyll, NexT">
<meta property="og:type" content="website">
<meta property="og:title" content="Immutable collections for JavaScript">
<meta property="og:url" content="http://localhost:4000/node_modules/immutable/">
<meta property="og:site_name" content="Yueran&apos;s Learning">
<meta property="og:description" content="# Immutable collections for JavaScript [![Build Status](https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml?query=branch%3Amain) [Chat on slack](https://immutable-js.slack.com) [Read the docs](https://immutable-js.com) and eat your vegetables. Docs are automatically generated from [README.md][] and [immutable.d.ts][]. Please contribute! Also, don&apos;t miss the [wiki][] which contains articles on additional specific topics. Can&apos;t find something? Open an [issue][]. **Table of contents:** - [Introduction](#introduction) - [Getting started](#getting-started) - [The case for Immutability](#the-case-for-immutability) - [JavaScript-first API](#javaScript-first-api) - [Nested Structures](#nested-structures) - [Equality treats Collections as Values](#equality-treats-collections-as-values) - [Batching Mutations](#batching-mutations) - [Lazy Seq](#lazy-seq) - [Additional Tools and Resources](#additional-tools-and-resources) - [Contributing](#contributing) ## Introduction [Immutable][] data cannot be changed once created, leading to much simpler application development, no defensive copying, and enabling advanced memoization and change detection techniques with simple logic. [Persistent][] data presents a mutative API which does not update the data in-place, but instead always yields new updated data. Immutable.js provides many Persistent Immutable data structures including: `List`, `Stack`, `Map`, `OrderedMap`, `Set`, `OrderedSet` and `Record`. These data structures are highly efficient on modern JavaScript VMs by using structural sharing via [hash maps tries][] and [vector tries][] as popularized by Clojure and Scala, minimizing the need to copy or cache data. Immutable.js also provides a lazy `Seq`, allowing efficient chaining of collection methods like `map` and `filter` without creating intermediate representations. Create some `Seq` with `Range` and `Repeat`. Want to hear more? Watch the presentation about Immutable.js: [![Immutable Data and React](website/public/Immutable-Data-and-React-YouTube.png)](https://youtu.be/I7IdS-PbEgI) [README.md]: https://github.com/immutable-js/immutable-js/blob/main/README.md [immutable.d.ts]: https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts [wiki]: https://github.com/immutable-js/immutable-js/wiki [issue]: https://github.com/immutable-js/immutable-js/issues [Persistent]: https://en.wikipedia.org/wiki/Persistent_data_structure [Immutable]: https://en.wikipedia.org/wiki/Immutable_object [hash maps tries]: https://en.wikipedia.org/wiki/Hash_array_mapped_trie [vector tries]: https://hypirion.com/musings/understanding-persistent-vector-pt-1 ## Getting started Install `immutable` using npm. ```shell npm install immutable ``` Or install using yarn. ```shell yarn add immutable ``` Then require it into any module. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;) + &apos; vs. &apos; + map2.get(&apos;b&apos;); // 2 vs. 50 ``` ### Browser Immutable.js has no dependencies, which makes it predictable to include in a Browser. It&apos;s highly recommended to use a module bundler like [webpack](https://webpack.github.io/), [rollup](https://rollupjs.org/), or [browserify](https://browserify.org/). The `immutable` npm module works without any additional consideration. All examples throughout the documentation will assume use of this kind of tool. Alternatively, Immutable.js may be directly included as a script tag. Download or link to a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable) or [jsDelivr](https://www.jsdelivr.com/package/npm/immutable). Use a script tag to directly add `Immutable` to the global scope: ```html ``` Or use an AMD-style loader (such as [RequireJS](https://requirejs.org/)): ```js require([&apos;./immutable.min.js&apos;], function (Immutable) { var map1 = Immutable.Map({ a: 1, b: 2, c: 3 }); var map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;); // 2 map2.get(&apos;b&apos;); // 50 }); ``` ### Flow &amp; TypeScript Use these Immutable collections and sequences as you would use native collections in your [Flowtype](https://flowtype.org/) or [TypeScript](https://typescriptlang.org) programs while still taking advantage of type generics, error detection, and auto-complete in your IDE. Installing `immutable` via npm brings with it type definitions for Flow (v0.55.0 or higher) and TypeScript (v2.1.0 or higher), so you shouldn&apos;t need to do anything at all! #### Using TypeScript with Immutable.js v4 Immutable.js type definitions embrace ES2015. While Immutable.js itself supports legacy browsers and environments, its type definitions require TypeScript&apos;s 2015 lib. Include either `&quot;target&quot;: &quot;es2015&quot;` or `&quot;lib&quot;: &quot;es2015&quot;` in your `tsconfig.json`, or provide `--target es2015` or `--lib es2015` to the `tsc` command. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;) + &apos; vs. &apos; + map2.get(&apos;b&apos;); // 2 vs. 50 ``` #### Using TypeScript with Immutable.js v3 and earlier: Previous versions of Immutable.js include a reference file which you can include via relative path to the type definitions at the top of your file. ```js /// import Immutable from &apos;immutable&apos;; var map1: Immutable.Map; map1 = Immutable.Map({ a: 1, b: 2, c: 3 }); var map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;); // 2 map2.get(&apos;b&apos;); // 50 ``` ## The case for Immutability Much of what makes application development difficult is tracking mutation and maintaining state. Developing with immutable data encourages you to think differently about how data flows through your application. Subscribing to data events throughout your application creates a huge overhead of book-keeping which can hurt performance, sometimes dramatically, and creates opportunities for areas of your application to get out of sync with each other due to easy to make programmer error. Since immutable data never changes, subscribing to changes throughout the model is a dead-end and new data can only ever be passed from above. This model of data flow aligns well with the architecture of [React][] and especially well with an application designed using the ideas of [Flux][]. When data is passed from above rather than being subscribed to, and you&apos;re only interested in doing work when something has changed, you can use equality. Immutable collections should be treated as _values_ rather than _objects_. While objects represent some thing which could change over time, a value represents the state of that thing at a particular instance of time. This principle is most important to understanding the appropriate use of immutable data. In order to treat Immutable.js collections as values, it&apos;s important to use the `Immutable.is()` function or `.equals()` method to determine _value equality_ instead of the `===` operator which determines object _reference identity_. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); map1.equals(map2); // true map1 === map2; // false ``` Note: As a performance optimization Immutable.js attempts to return the existing collection when an operation would result in an identical collection, allowing for using `===` reference equality to determine if something definitely has not changed. This can be extremely useful when used within a memoization function which would prefer to re-run the function if a deeper equality check could potentially be more costly. The `===` equality check is also used internally by `Immutable.is` and `.equals()` as a performance optimization. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 2); // Set to same value map1 === map2; // true ``` If an object is immutable, it can be &quot;copied&quot; simply by making another reference to it instead of copying the entire object. Because a reference is much smaller than the object itself, this results in memory savings and a potential boost in execution speed for programs which rely on copies (such as an undo-stack). ```js const { Map } = require(&apos;immutable&apos;); const map = Map({ a: 1, b: 2, c: 3 }); const mapCopy = map; // Look, &quot;copies&quot; are free! ``` [React]: https://reactjs.org/ [Flux]: https://facebook.github.io/flux/docs/in-depth-overview/ ## JavaScript-first API While Immutable.js is inspired by Clojure, Scala, Haskell and other functional programming environments, it&apos;s designed to bring these powerful concepts to JavaScript, and therefore has an Object-Oriented API that closely mirrors that of [ES2015][] [Array][], [Map][], and [Set][]. [es2015]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla [array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array [map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map [set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set The difference for the immutable collections is that methods which would mutate the collection, like `push`, `set`, `unshift` or `splice`, instead return a new immutable collection. Methods which return new arrays, like `slice` or `concat`, instead return new immutable collections. ```js const { List } = require(&apos;immutable&apos;); const list1 = List([1, 2]); const list2 = list1.push(3, 4, 5); const list3 = list2.unshift(0); const list4 = list1.concat(list2, list3); assert.equal(list1.size, 2); assert.equal(list2.size, 5); assert.equal(list3.size, 6); assert.equal(list4.size, 13); assert.equal(list4.get(0), 1); ``` Almost all of the methods on [Array][] will be found in similar form on `Immutable.List`, those of [Map][] found on `Immutable.Map`, and those of [Set][] found on `Immutable.Set`, including collection operations like `forEach()` and `map()`. ```js const { Map } = require(&apos;immutable&apos;); const alpha = Map({ a: 1, b: 2, c: 3, d: 4 }); alpha.map((v, k) =&amp;gt; k.toUpperCase()).join(); // &apos;A,B,C,D&apos; ``` ### Convert from raw JavaScript objects and arrays. Designed to inter-operate with your existing JavaScript, Immutable.js accepts plain JavaScript Arrays and Objects anywhere a method expects a `Collection`. ```js const { Map, List } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3, d: 4 }); const map2 = Map({ c: 10, a: 20, t: 30 }); const obj = { d: 100, o: 200, g: 300 }; const map3 = map1.merge(map2, obj); // Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 } const list1 = List([1, 2, 3]); const list2 = List([4, 5, 6]); const array = [7, 8, 9]; const list3 = list1.concat(list2, array); // List [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] ``` This is possible because Immutable.js can treat any JavaScript Array or Object as a Collection. You can take advantage of this in order to get sophisticated collection methods on JavaScript Objects, which otherwise have a very sparse native API. Because Seq evaluates lazily and does not cache intermediate results, these operations can be extremely efficient. ```js const { Seq } = require(&apos;immutable&apos;); const myObject = { a: 1, b: 2, c: 3 }; Seq(myObject) .map(x =&amp;gt; x * x) .toObject(); // { a: 1, b: 4, c: 9 } ``` Keep in mind, when using JS objects to construct Immutable Maps, that JavaScript Object properties are always strings, even if written in a quote-less shorthand, while Immutable Maps accept keys of any type. ```js const { fromJS } = require(&apos;immutable&apos;); const obj = { 1: &apos;one&apos; }; console.log(Object.keys(obj)); // [ &quot;1&quot; ] console.log(obj[&apos;1&apos;], obj[1]); // &quot;one&quot;, &quot;one&quot; const map = fromJS(obj); console.log(map.get(&apos;1&apos;), map.get(1)); // &quot;one&quot;, undefined ``` Property access for JavaScript Objects first converts the key to a string, but since Immutable Map keys can be of any type the argument to `get()` is not altered. ### Converts back to raw JavaScript objects. All Immutable.js Collections can be converted to plain JavaScript Arrays and Objects shallowly with `toArray()` and `toObject()` or deeply with `toJS()`. All Immutable Collections also implement `toJSON()` allowing them to be passed to `JSON.stringify` directly. They also respect the custom `toJSON()` methods of nested objects. ```js const { Map, List } = require(&apos;immutable&apos;); const deep = Map({ a: 1, b: 2, c: List([3, 4, 5]) }); console.log(deep.toObject()); // { a: 1, b: 2, c: List [ 3, 4, 5 ] } console.log(deep.toArray()); // [ 1, 2, List [ 3, 4, 5 ] ] console.log(deep.toJS()); // { a: 1, b: 2, c: [ 3, 4, 5 ] } JSON.stringify(deep); // &apos;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[3,4,5]}&apos; ``` ### Embraces ES2015 Immutable.js supports all JavaScript environments, including legacy browsers (even IE11). However it also takes advantage of features added to JavaScript in [ES2015][], the latest standard version of JavaScript, including [Iterators][], [Arrow Functions][], [Classes][], and [Modules][]. It&apos;s inspired by the native [Map][] and [Set][] collections added to ES2015. All examples in the Documentation are presented in ES2015. To run in all browsers, they need to be translated to ES5. ```js // ES2015 const mapped = foo.map(x =&amp;gt; x * x); // ES5 var mapped = foo.map(function (x) { return x * x; }); ``` All Immutable.js collections are [Iterable][iterators], which allows them to be used anywhere an Iterable is expected, such as when spreading into an Array. ```js const { List } = require(&apos;immutable&apos;); const aList = List([1, 2, 3]); const anArray = [0, ...aList, 4, 5]; // [ 0, 1, 2, 3, 4, 5 ] ``` Note: A Collection is always iterated in the same order, however that order may not always be well defined, as is the case for the `Map` and `Set`. [Iterators]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol [Arrow Functions]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions [Classes]: https://wiki.ecmascript.org/doku.php?id=strawman:maximally_minimal_classes [Modules]: https://www.2ality.com/2014/09/es6-modules-final.html ## Nested Structures The collections in Immutable.js are intended to be nested, allowing for deep trees of data, similar to JSON. ```js const { fromJS } = require(&apos;immutable&apos;); const nested = fromJS({ a: { b: { c: [3, 4, 5] } } }); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } } ``` A few power-tools allow for reading and operating on nested data. The most useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`, `Map` and `OrderedMap`. ```js const { fromJS } = require(&apos;immutable&apos;); const nested = fromJS({ a: { b: { c: [3, 4, 5] } } }); const nested2 = nested.mergeDeep({ a: { b: { d: 6 } } }); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } } console.log(nested2.getIn([&apos;a&apos;, &apos;b&apos;, &apos;d&apos;])); // 6 const nested3 = nested2.updateIn([&apos;a&apos;, &apos;b&apos;, &apos;d&apos;], value =&amp;gt; value + 1); console.log(nested3); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } } const nested4 = nested3.updateIn([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], list =&amp;gt; list.push(6)); // Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } } ``` ## Equality treats Collections as Values Immutable.js collections are treated as pure data _values_. Two immutable collections are considered _value equal_ (via `.equals()` or `is()`) if they represent the same collection of values. This differs from JavaScript&apos;s typical _reference equal_ (via `===` or `==`) for Objects and Arrays which only determines if two variables represent references to the same object instance. Consider the example below where two identical `Map` instances are not _reference equal_ but are _value equal_. ```js // First consider: const obj1 = { a: 1, b: 2, c: 3 }; const obj2 = { a: 1, b: 2, c: 3 }; obj1 !== obj2; // two different instances are always not equal with === const { Map, is } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); map1 !== map2; // two different instances are not reference-equal map1.equals(map2); // but are value-equal if they have the same values is(map1, map2); // alternatively can use the is() function ``` Value equality allows Immutable.js collections to be used as keys in Maps or values in Sets, and retrieved with different but equivalent collections: ```js const { Map, Set } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); const set = Set().add(map1); set.has(map2); // true because these are value-equal ``` Note: `is()` uses the same measure of equality as [Object.is][] for scalar strings and numbers, but uses value equality for Immutable collections, determining if both are immutable and all keys and values are equal using the same measure of equality. [object.is]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is #### Performance tradeoffs While value equality is useful in many circumstances, it has different performance characteristics than reference equality. Understanding these tradeoffs may help you decide which to use in each case, especially when used to memoize some operation. When comparing two collections, value equality may require considering every item in each collection, on an `O(N)` time complexity. For large collections of values, this could become a costly operation. Though if the two are not equal and hardly similar, the inequality is determined very quickly. In contrast, when comparing two collections with reference equality, only the initial references to memory need to be compared which is not based on the size of the collections, which has an `O(1)` time complexity. Checking reference equality is always very fast, however just because two collections are not reference-equal does not rule out the possibility that they may be value-equal. #### Return self on no-op optimization When possible, Immutable.js avoids creating new objects for updates where no change in _value_ occurred, to allow for efficient _reference equality_ checking to quickly determine if no change occurred. ```js const { Map } = require(&apos;immutable&apos;); const originalMap = Map({ a: 1, b: 2, c: 3 }); const updatedMap = originalMap.set(&apos;b&apos;, 2); updatedMap === originalMap; // No-op .set() returned the original reference. ``` However updates which do result in a change will return a new reference. Each of these operations occur independently, so two similar updates will not return the same reference: ```js const { Map } = require(&apos;immutable&apos;); const originalMap = Map({ a: 1, b: 2, c: 3 }); const updatedMap = originalMap.set(&apos;b&apos;, 1000); // New instance, leaving the original immutable. updatedMap !== originalMap; const anotherUpdatedMap = originalMap.set(&apos;b&apos;, 1000); // Despite both the results of the same operation, each created a new reference. anotherUpdatedMap !== updatedMap; // However the two are value equal. anotherUpdatedMap.equals(updatedMap); ``` ## Batching Mutations &amp;gt; If a tree falls in the woods, does it make a sound? &amp;gt; &amp;gt; If a pure function mutates some local data in order to produce an immutable &amp;gt; return value, is that ok? &amp;gt; &amp;gt; — Rich Hickey, Clojure Applying a mutation to create a new immutable object results in some overhead, which can add up to a minor performance penalty. If you need to apply a series of mutations locally before returning, Immutable.js gives you the ability to create a temporary mutable (transient) copy of a collection and apply a batch of mutations in a performant manner by using `withMutations`. In fact, this is exactly how Immutable.js applies complex mutations itself. As an example, building `list2` results in the creation of 1, not 3, new immutable Lists. ```js const { List } = require(&apos;immutable&apos;); const list1 = List([1, 2, 3]); const list2 = list1.withMutations(function (list) { list.push(4).push(5).push(6); }); assert.equal(list1.size, 3); assert.equal(list2.size, 6); ``` Note: Immutable.js also provides `asMutable` and `asImmutable`, but only encourages their use when `withMutations` will not suffice. Use caution to not return a mutable copy, which could result in undesired behavior. _Important!_: Only a select few methods can be used in `withMutations` including `set`, `push` and `pop`. These methods can be applied directly against a persistent data-structure where other methods like `map`, `filter`, `sort`, and `splice` will always return new immutable data-structures and never mutate a mutable collection. ## Lazy Seq `Seq` describes a lazy operation, allowing them to efficiently chain use of all the higher-order collection methods (such as `map` and `filter`) by not creating intermediate collections. **Seq is immutable** — Once a Seq is created, it cannot be changed, appended to, rearranged or otherwise modified. Instead, any mutative method called on a `Seq` will return a new `Seq`. **Seq is lazy** — `Seq` does as little work as necessary to respond to any method call. Values are often created during iteration, including implicit iteration when reducing or converting to a concrete data structure such as a `List` or JavaScript `Array`. For example, the following performs no work, because the resulting `Seq`&apos;s values are never iterated: ```js const { Seq } = require(&apos;immutable&apos;); const oddSquares = Seq([1, 2, 3, 4, 5, 6, 7, 8]) .filter(x =&amp;gt; x % 2 !== 0) .map(x =&amp;gt; x * x); ``` Once the `Seq` is used, it performs only the work necessary. In this example, no intermediate arrays are ever created, filter is called three times, and map is only called once: ```js oddSquares.get(1); // 9 ``` Any collection can be converted to a lazy Seq with `Seq()`. ```js const { Map, Seq } = require(&apos;immutable&apos;); const map = Map({ a: 1, b: 2, c: 3 }); const lazySeq = Seq(map); ``` `Seq` allows for the efficient chaining of operations, allowing for the expression of logic that can otherwise be very tedious: ```js lazySeq .flip() .map(key =&amp;gt; key.toUpperCase()) .flip(); // Seq { A: 1, B: 2, C: 3 } ``` As well as expressing logic that would otherwise seem memory or time limited, for example `Range` is a special kind of Lazy sequence. ```js const { Range } = require(&apos;immutable&apos;); Range(1, Infinity) .skip(1000) .map(n =&amp;gt; -n) .filter(n =&amp;gt; n % 2 === 0) .take(2) .reduce((r, n) =&amp;gt; r * n, 1); // 1006008 ``` ## Additional Tools and Resources - [Atom-store](https://github.com/jameshopkins/atom-store/) - A Clojure-inspired atom implementation in Javascript with configurability for external persistance. - [Chai Immutable](https://github.com/astorije/chai-immutable) - If you are using the [Chai Assertion Library](https://chaijs.com/), this provides a set of assertions to use against Immutable.js collections. - [Fantasy-land](https://github.com/fantasyland/fantasy-land) - Specification for interoperability of common algebraic structures in JavaScript. - [Immutagen](https://github.com/pelotom/immutagen) - A library for simulating immutable generators in JavaScript. - [Immutable-cursor](https://github.com/redbadger/immutable-cursor) - Immutable cursors incorporating the Immutable.js interface over Clojure-inspired atom. - [Immutable-ext](https://github.com/DrBoolean/immutable-ext) - Fantasyland extensions for immutablejs - [Immutable-js-tools](https://github.com/madeinfree/immutable-js-tools) - Util tools for immutable.js - [Immutable-Redux](https://github.com/gajus/redux-immutable) - redux-immutable is used to create an equivalent function of Redux combineReducers that works with Immutable.js state. - [Immutable-Treeutils](https://github.com/lukasbuenger/immutable-treeutils) - Functional tree traversal helpers for ImmutableJS data structures. - [Irecord](https://github.com/ericelliott/irecord) - An immutable store that exposes an RxJS observable. Great for React. - [Mudash](https://github.com/brianneisler/mudash) - Lodash wrapper providing Immutable.JS support. - [React-Immutable-PropTypes](https://github.com/HurricaneJames/react-immutable-proptypes) - PropType validators that work with Immutable.js. - [Redux-Immutablejs](https://github.com/indexiatech/redux-immutablejs) - Redux Immutable facilities. - [Rxstate](https://github.com/yamalight/rxstate) - Simple opinionated state management library based on RxJS and Immutable.js. - [Transit-Immutable-js](https://github.com/glenjamin/transit-immutable-js) - Transit serialisation for Immutable.js. - See also: [Transit-js](https://github.com/cognitect/transit-js) Have an additional tool designed to work with Immutable.js? Submit a PR to add it to this list in alphabetical order. ## Contributing Use [Github issues](https://github.com/immutable-js/immutable-js/issues) for requests. We actively welcome pull requests, learn how to [contribute](https://github.com/immutable-js/immutable-js/blob/main/.github/CONTRIBUTING.md). Immutable.js is maintained within the [Contributor Covenant&apos;s Code of Conduct](https://www.contributor-covenant.org/version/2/0/code_of_conduct/). ### Changelog Changes are tracked as [Github releases](https://github.com/immutable-js/immutable-js/releases). ### License Immutable.js is [MIT-licensed](/node_modules/immutable/LICENSE). ### Thanks [Phil Bagwell](https://www.youtube.com/watch?v=K2NYwP90bNs), for his inspiration and research in persistent data structures. [Hugh Jackson](https://github.com/hughfdjackson/), for providing the npm package name. If you&apos;re looking for his unsupported package, see [this repository](https://github.com/hughfdjackson/immutable).">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Immutable collections for JavaScript">
<meta name="twitter:description" content="# Immutable collections for JavaScript [![Build Status](https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml?query=branch%3Amain) [Chat on slack](https://immutable-js.slack.com) [Read the docs](https://immutable-js.com) and eat your vegetables. Docs are automatically generated from [README.md][] and [immutable.d.ts][]. Please contribute! Also, don&apos;t miss the [wiki][] which contains articles on additional specific topics. Can&apos;t find something? Open an [issue][]. **Table of contents:** - [Introduction](#introduction) - [Getting started](#getting-started) - [The case for Immutability](#the-case-for-immutability) - [JavaScript-first API](#javaScript-first-api) - [Nested Structures](#nested-structures) - [Equality treats Collections as Values](#equality-treats-collections-as-values) - [Batching Mutations](#batching-mutations) - [Lazy Seq](#lazy-seq) - [Additional Tools and Resources](#additional-tools-and-resources) - [Contributing](#contributing) ## Introduction [Immutable][] data cannot be changed once created, leading to much simpler application development, no defensive copying, and enabling advanced memoization and change detection techniques with simple logic. [Persistent][] data presents a mutative API which does not update the data in-place, but instead always yields new updated data. Immutable.js provides many Persistent Immutable data structures including: `List`, `Stack`, `Map`, `OrderedMap`, `Set`, `OrderedSet` and `Record`. These data structures are highly efficient on modern JavaScript VMs by using structural sharing via [hash maps tries][] and [vector tries][] as popularized by Clojure and Scala, minimizing the need to copy or cache data. Immutable.js also provides a lazy `Seq`, allowing efficient chaining of collection methods like `map` and `filter` without creating intermediate representations. Create some `Seq` with `Range` and `Repeat`. Want to hear more? Watch the presentation about Immutable.js: [![Immutable Data and React](website/public/Immutable-Data-and-React-YouTube.png)](https://youtu.be/I7IdS-PbEgI) [README.md]: https://github.com/immutable-js/immutable-js/blob/main/README.md [immutable.d.ts]: https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts [wiki]: https://github.com/immutable-js/immutable-js/wiki [issue]: https://github.com/immutable-js/immutable-js/issues [Persistent]: https://en.wikipedia.org/wiki/Persistent_data_structure [Immutable]: https://en.wikipedia.org/wiki/Immutable_object [hash maps tries]: https://en.wikipedia.org/wiki/Hash_array_mapped_trie [vector tries]: https://hypirion.com/musings/understanding-persistent-vector-pt-1 ## Getting started Install `immutable` using npm. ```shell npm install immutable ``` Or install using yarn. ```shell yarn add immutable ``` Then require it into any module. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;) + &apos; vs. &apos; + map2.get(&apos;b&apos;); // 2 vs. 50 ``` ### Browser Immutable.js has no dependencies, which makes it predictable to include in a Browser. It&apos;s highly recommended to use a module bundler like [webpack](https://webpack.github.io/), [rollup](https://rollupjs.org/), or [browserify](https://browserify.org/). The `immutable` npm module works without any additional consideration. All examples throughout the documentation will assume use of this kind of tool. Alternatively, Immutable.js may be directly included as a script tag. Download or link to a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable) or [jsDelivr](https://www.jsdelivr.com/package/npm/immutable). Use a script tag to directly add `Immutable` to the global scope: ```html ``` Or use an AMD-style loader (such as [RequireJS](https://requirejs.org/)): ```js require([&apos;./immutable.min.js&apos;], function (Immutable) { var map1 = Immutable.Map({ a: 1, b: 2, c: 3 }); var map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;); // 2 map2.get(&apos;b&apos;); // 50 }); ``` ### Flow &amp; TypeScript Use these Immutable collections and sequences as you would use native collections in your [Flowtype](https://flowtype.org/) or [TypeScript](https://typescriptlang.org) programs while still taking advantage of type generics, error detection, and auto-complete in your IDE. Installing `immutable` via npm brings with it type definitions for Flow (v0.55.0 or higher) and TypeScript (v2.1.0 or higher), so you shouldn&apos;t need to do anything at all! #### Using TypeScript with Immutable.js v4 Immutable.js type definitions embrace ES2015. While Immutable.js itself supports legacy browsers and environments, its type definitions require TypeScript&apos;s 2015 lib. Include either `&quot;target&quot;: &quot;es2015&quot;` or `&quot;lib&quot;: &quot;es2015&quot;` in your `tsconfig.json`, or provide `--target es2015` or `--lib es2015` to the `tsc` command. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;) + &apos; vs. &apos; + map2.get(&apos;b&apos;); // 2 vs. 50 ``` #### Using TypeScript with Immutable.js v3 and earlier: Previous versions of Immutable.js include a reference file which you can include via relative path to the type definitions at the top of your file. ```js /// import Immutable from &apos;immutable&apos;; var map1: Immutable.Map; map1 = Immutable.Map({ a: 1, b: 2, c: 3 }); var map2 = map1.set(&apos;b&apos;, 50); map1.get(&apos;b&apos;); // 2 map2.get(&apos;b&apos;); // 50 ``` ## The case for Immutability Much of what makes application development difficult is tracking mutation and maintaining state. Developing with immutable data encourages you to think differently about how data flows through your application. Subscribing to data events throughout your application creates a huge overhead of book-keeping which can hurt performance, sometimes dramatically, and creates opportunities for areas of your application to get out of sync with each other due to easy to make programmer error. Since immutable data never changes, subscribing to changes throughout the model is a dead-end and new data can only ever be passed from above. This model of data flow aligns well with the architecture of [React][] and especially well with an application designed using the ideas of [Flux][]. When data is passed from above rather than being subscribed to, and you&apos;re only interested in doing work when something has changed, you can use equality. Immutable collections should be treated as _values_ rather than _objects_. While objects represent some thing which could change over time, a value represents the state of that thing at a particular instance of time. This principle is most important to understanding the appropriate use of immutable data. In order to treat Immutable.js collections as values, it&apos;s important to use the `Immutable.is()` function or `.equals()` method to determine _value equality_ instead of the `===` operator which determines object _reference identity_. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); map1.equals(map2); // true map1 === map2; // false ``` Note: As a performance optimization Immutable.js attempts to return the existing collection when an operation would result in an identical collection, allowing for using `===` reference equality to determine if something definitely has not changed. This can be extremely useful when used within a memoization function which would prefer to re-run the function if a deeper equality check could potentially be more costly. The `===` equality check is also used internally by `Immutable.is` and `.equals()` as a performance optimization. ```js const { Map } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = map1.set(&apos;b&apos;, 2); // Set to same value map1 === map2; // true ``` If an object is immutable, it can be &quot;copied&quot; simply by making another reference to it instead of copying the entire object. Because a reference is much smaller than the object itself, this results in memory savings and a potential boost in execution speed for programs which rely on copies (such as an undo-stack). ```js const { Map } = require(&apos;immutable&apos;); const map = Map({ a: 1, b: 2, c: 3 }); const mapCopy = map; // Look, &quot;copies&quot; are free! ``` [React]: https://reactjs.org/ [Flux]: https://facebook.github.io/flux/docs/in-depth-overview/ ## JavaScript-first API While Immutable.js is inspired by Clojure, Scala, Haskell and other functional programming environments, it&apos;s designed to bring these powerful concepts to JavaScript, and therefore has an Object-Oriented API that closely mirrors that of [ES2015][] [Array][], [Map][], and [Set][]. [es2015]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla [array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array [map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map [set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set The difference for the immutable collections is that methods which would mutate the collection, like `push`, `set`, `unshift` or `splice`, instead return a new immutable collection. Methods which return new arrays, like `slice` or `concat`, instead return new immutable collections. ```js const { List } = require(&apos;immutable&apos;); const list1 = List([1, 2]); const list2 = list1.push(3, 4, 5); const list3 = list2.unshift(0); const list4 = list1.concat(list2, list3); assert.equal(list1.size, 2); assert.equal(list2.size, 5); assert.equal(list3.size, 6); assert.equal(list4.size, 13); assert.equal(list4.get(0), 1); ``` Almost all of the methods on [Array][] will be found in similar form on `Immutable.List`, those of [Map][] found on `Immutable.Map`, and those of [Set][] found on `Immutable.Set`, including collection operations like `forEach()` and `map()`. ```js const { Map } = require(&apos;immutable&apos;); const alpha = Map({ a: 1, b: 2, c: 3, d: 4 }); alpha.map((v, k) =&amp;gt; k.toUpperCase()).join(); // &apos;A,B,C,D&apos; ``` ### Convert from raw JavaScript objects and arrays. Designed to inter-operate with your existing JavaScript, Immutable.js accepts plain JavaScript Arrays and Objects anywhere a method expects a `Collection`. ```js const { Map, List } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3, d: 4 }); const map2 = Map({ c: 10, a: 20, t: 30 }); const obj = { d: 100, o: 200, g: 300 }; const map3 = map1.merge(map2, obj); // Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 } const list1 = List([1, 2, 3]); const list2 = List([4, 5, 6]); const array = [7, 8, 9]; const list3 = list1.concat(list2, array); // List [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] ``` This is possible because Immutable.js can treat any JavaScript Array or Object as a Collection. You can take advantage of this in order to get sophisticated collection methods on JavaScript Objects, which otherwise have a very sparse native API. Because Seq evaluates lazily and does not cache intermediate results, these operations can be extremely efficient. ```js const { Seq } = require(&apos;immutable&apos;); const myObject = { a: 1, b: 2, c: 3 }; Seq(myObject) .map(x =&amp;gt; x * x) .toObject(); // { a: 1, b: 4, c: 9 } ``` Keep in mind, when using JS objects to construct Immutable Maps, that JavaScript Object properties are always strings, even if written in a quote-less shorthand, while Immutable Maps accept keys of any type. ```js const { fromJS } = require(&apos;immutable&apos;); const obj = { 1: &apos;one&apos; }; console.log(Object.keys(obj)); // [ &quot;1&quot; ] console.log(obj[&apos;1&apos;], obj[1]); // &quot;one&quot;, &quot;one&quot; const map = fromJS(obj); console.log(map.get(&apos;1&apos;), map.get(1)); // &quot;one&quot;, undefined ``` Property access for JavaScript Objects first converts the key to a string, but since Immutable Map keys can be of any type the argument to `get()` is not altered. ### Converts back to raw JavaScript objects. All Immutable.js Collections can be converted to plain JavaScript Arrays and Objects shallowly with `toArray()` and `toObject()` or deeply with `toJS()`. All Immutable Collections also implement `toJSON()` allowing them to be passed to `JSON.stringify` directly. They also respect the custom `toJSON()` methods of nested objects. ```js const { Map, List } = require(&apos;immutable&apos;); const deep = Map({ a: 1, b: 2, c: List([3, 4, 5]) }); console.log(deep.toObject()); // { a: 1, b: 2, c: List [ 3, 4, 5 ] } console.log(deep.toArray()); // [ 1, 2, List [ 3, 4, 5 ] ] console.log(deep.toJS()); // { a: 1, b: 2, c: [ 3, 4, 5 ] } JSON.stringify(deep); // &apos;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[3,4,5]}&apos; ``` ### Embraces ES2015 Immutable.js supports all JavaScript environments, including legacy browsers (even IE11). However it also takes advantage of features added to JavaScript in [ES2015][], the latest standard version of JavaScript, including [Iterators][], [Arrow Functions][], [Classes][], and [Modules][]. It&apos;s inspired by the native [Map][] and [Set][] collections added to ES2015. All examples in the Documentation are presented in ES2015. To run in all browsers, they need to be translated to ES5. ```js // ES2015 const mapped = foo.map(x =&amp;gt; x * x); // ES5 var mapped = foo.map(function (x) { return x * x; }); ``` All Immutable.js collections are [Iterable][iterators], which allows them to be used anywhere an Iterable is expected, such as when spreading into an Array. ```js const { List } = require(&apos;immutable&apos;); const aList = List([1, 2, 3]); const anArray = [0, ...aList, 4, 5]; // [ 0, 1, 2, 3, 4, 5 ] ``` Note: A Collection is always iterated in the same order, however that order may not always be well defined, as is the case for the `Map` and `Set`. [Iterators]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol [Arrow Functions]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions [Classes]: https://wiki.ecmascript.org/doku.php?id=strawman:maximally_minimal_classes [Modules]: https://www.2ality.com/2014/09/es6-modules-final.html ## Nested Structures The collections in Immutable.js are intended to be nested, allowing for deep trees of data, similar to JSON. ```js const { fromJS } = require(&apos;immutable&apos;); const nested = fromJS({ a: { b: { c: [3, 4, 5] } } }); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } } ``` A few power-tools allow for reading and operating on nested data. The most useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`, `Map` and `OrderedMap`. ```js const { fromJS } = require(&apos;immutable&apos;); const nested = fromJS({ a: { b: { c: [3, 4, 5] } } }); const nested2 = nested.mergeDeep({ a: { b: { d: 6 } } }); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } } console.log(nested2.getIn([&apos;a&apos;, &apos;b&apos;, &apos;d&apos;])); // 6 const nested3 = nested2.updateIn([&apos;a&apos;, &apos;b&apos;, &apos;d&apos;], value =&amp;gt; value + 1); console.log(nested3); // Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } } const nested4 = nested3.updateIn([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], list =&amp;gt; list.push(6)); // Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } } ``` ## Equality treats Collections as Values Immutable.js collections are treated as pure data _values_. Two immutable collections are considered _value equal_ (via `.equals()` or `is()`) if they represent the same collection of values. This differs from JavaScript&apos;s typical _reference equal_ (via `===` or `==`) for Objects and Arrays which only determines if two variables represent references to the same object instance. Consider the example below where two identical `Map` instances are not _reference equal_ but are _value equal_. ```js // First consider: const obj1 = { a: 1, b: 2, c: 3 }; const obj2 = { a: 1, b: 2, c: 3 }; obj1 !== obj2; // two different instances are always not equal with === const { Map, is } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); map1 !== map2; // two different instances are not reference-equal map1.equals(map2); // but are value-equal if they have the same values is(map1, map2); // alternatively can use the is() function ``` Value equality allows Immutable.js collections to be used as keys in Maps or values in Sets, and retrieved with different but equivalent collections: ```js const { Map, Set } = require(&apos;immutable&apos;); const map1 = Map({ a: 1, b: 2, c: 3 }); const map2 = Map({ a: 1, b: 2, c: 3 }); const set = Set().add(map1); set.has(map2); // true because these are value-equal ``` Note: `is()` uses the same measure of equality as [Object.is][] for scalar strings and numbers, but uses value equality for Immutable collections, determining if both are immutable and all keys and values are equal using the same measure of equality. [object.is]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is #### Performance tradeoffs While value equality is useful in many circumstances, it has different performance characteristics than reference equality. Understanding these tradeoffs may help you decide which to use in each case, especially when used to memoize some operation. When comparing two collections, value equality may require considering every item in each collection, on an `O(N)` time complexity. For large collections of values, this could become a costly operation. Though if the two are not equal and hardly similar, the inequality is determined very quickly. In contrast, when comparing two collections with reference equality, only the initial references to memory need to be compared which is not based on the size of the collections, which has an `O(1)` time complexity. Checking reference equality is always very fast, however just because two collections are not reference-equal does not rule out the possibility that they may be value-equal. #### Return self on no-op optimization When possible, Immutable.js avoids creating new objects for updates where no change in _value_ occurred, to allow for efficient _reference equality_ checking to quickly determine if no change occurred. ```js const { Map } = require(&apos;immutable&apos;); const originalMap = Map({ a: 1, b: 2, c: 3 }); const updatedMap = originalMap.set(&apos;b&apos;, 2); updatedMap === originalMap; // No-op .set() returned the original reference. ``` However updates which do result in a change will return a new reference. Each of these operations occur independently, so two similar updates will not return the same reference: ```js const { Map } = require(&apos;immutable&apos;); const originalMap = Map({ a: 1, b: 2, c: 3 }); const updatedMap = originalMap.set(&apos;b&apos;, 1000); // New instance, leaving the original immutable. updatedMap !== originalMap; const anotherUpdatedMap = originalMap.set(&apos;b&apos;, 1000); // Despite both the results of the same operation, each created a new reference. anotherUpdatedMap !== updatedMap; // However the two are value equal. anotherUpdatedMap.equals(updatedMap); ``` ## Batching Mutations &amp;gt; If a tree falls in the woods, does it make a sound? &amp;gt; &amp;gt; If a pure function mutates some local data in order to produce an immutable &amp;gt; return value, is that ok? &amp;gt; &amp;gt; — Rich Hickey, Clojure Applying a mutation to create a new immutable object results in some overhead, which can add up to a minor performance penalty. If you need to apply a series of mutations locally before returning, Immutable.js gives you the ability to create a temporary mutable (transient) copy of a collection and apply a batch of mutations in a performant manner by using `withMutations`. In fact, this is exactly how Immutable.js applies complex mutations itself. As an example, building `list2` results in the creation of 1, not 3, new immutable Lists. ```js const { List } = require(&apos;immutable&apos;); const list1 = List([1, 2, 3]); const list2 = list1.withMutations(function (list) { list.push(4).push(5).push(6); }); assert.equal(list1.size, 3); assert.equal(list2.size, 6); ``` Note: Immutable.js also provides `asMutable` and `asImmutable`, but only encourages their use when `withMutations` will not suffice. Use caution to not return a mutable copy, which could result in undesired behavior. _Important!_: Only a select few methods can be used in `withMutations` including `set`, `push` and `pop`. These methods can be applied directly against a persistent data-structure where other methods like `map`, `filter`, `sort`, and `splice` will always return new immutable data-structures and never mutate a mutable collection. ## Lazy Seq `Seq` describes a lazy operation, allowing them to efficiently chain use of all the higher-order collection methods (such as `map` and `filter`) by not creating intermediate collections. **Seq is immutable** — Once a Seq is created, it cannot be changed, appended to, rearranged or otherwise modified. Instead, any mutative method called on a `Seq` will return a new `Seq`. **Seq is lazy** — `Seq` does as little work as necessary to respond to any method call. Values are often created during iteration, including implicit iteration when reducing or converting to a concrete data structure such as a `List` or JavaScript `Array`. For example, the following performs no work, because the resulting `Seq`&apos;s values are never iterated: ```js const { Seq } = require(&apos;immutable&apos;); const oddSquares = Seq([1, 2, 3, 4, 5, 6, 7, 8]) .filter(x =&amp;gt; x % 2 !== 0) .map(x =&amp;gt; x * x); ``` Once the `Seq` is used, it performs only the work necessary. In this example, no intermediate arrays are ever created, filter is called three times, and map is only called once: ```js oddSquares.get(1); // 9 ``` Any collection can be converted to a lazy Seq with `Seq()`. ```js const { Map, Seq } = require(&apos;immutable&apos;); const map = Map({ a: 1, b: 2, c: 3 }); const lazySeq = Seq(map); ``` `Seq` allows for the efficient chaining of operations, allowing for the expression of logic that can otherwise be very tedious: ```js lazySeq .flip() .map(key =&amp;gt; key.toUpperCase()) .flip(); // Seq { A: 1, B: 2, C: 3 } ``` As well as expressing logic that would otherwise seem memory or time limited, for example `Range` is a special kind of Lazy sequence. ```js const { Range } = require(&apos;immutable&apos;); Range(1, Infinity) .skip(1000) .map(n =&amp;gt; -n) .filter(n =&amp;gt; n % 2 === 0) .take(2) .reduce((r, n) =&amp;gt; r * n, 1); // 1006008 ``` ## Additional Tools and Resources - [Atom-store](https://github.com/jameshopkins/atom-store/) - A Clojure-inspired atom implementation in Javascript with configurability for external persistance. - [Chai Immutable](https://github.com/astorije/chai-immutable) - If you are using the [Chai Assertion Library](https://chaijs.com/), this provides a set of assertions to use against Immutable.js collections. - [Fantasy-land](https://github.com/fantasyland/fantasy-land) - Specification for interoperability of common algebraic structures in JavaScript. - [Immutagen](https://github.com/pelotom/immutagen) - A library for simulating immutable generators in JavaScript. - [Immutable-cursor](https://github.com/redbadger/immutable-cursor) - Immutable cursors incorporating the Immutable.js interface over Clojure-inspired atom. - [Immutable-ext](https://github.com/DrBoolean/immutable-ext) - Fantasyland extensions for immutablejs - [Immutable-js-tools](https://github.com/madeinfree/immutable-js-tools) - Util tools for immutable.js - [Immutable-Redux](https://github.com/gajus/redux-immutable) - redux-immutable is used to create an equivalent function of Redux combineReducers that works with Immutable.js state. - [Immutable-Treeutils](https://github.com/lukasbuenger/immutable-treeutils) - Functional tree traversal helpers for ImmutableJS data structures. - [Irecord](https://github.com/ericelliott/irecord) - An immutable store that exposes an RxJS observable. Great for React. - [Mudash](https://github.com/brianneisler/mudash) - Lodash wrapper providing Immutable.JS support. - [React-Immutable-PropTypes](https://github.com/HurricaneJames/react-immutable-proptypes) - PropType validators that work with Immutable.js. - [Redux-Immutablejs](https://github.com/indexiatech/redux-immutablejs) - Redux Immutable facilities. - [Rxstate](https://github.com/yamalight/rxstate) - Simple opinionated state management library based on RxJS and Immutable.js. - [Transit-Immutable-js](https://github.com/glenjamin/transit-immutable-js) - Transit serialisation for Immutable.js. - See also: [Transit-js](https://github.com/cognitect/transit-js) Have an additional tool designed to work with Immutable.js? Submit a PR to add it to this list in alphabetical order. ## Contributing Use [Github issues](https://github.com/immutable-js/immutable-js/issues) for requests. We actively welcome pull requests, learn how to [contribute](https://github.com/immutable-js/immutable-js/blob/main/.github/CONTRIBUTING.md). Immutable.js is maintained within the [Contributor Covenant&apos;s Code of Conduct](https://www.contributor-covenant.org/version/2/0/code_of_conduct/). ### Changelog Changes are tracked as [Github releases](https://github.com/immutable-js/immutable-js/releases). ### License Immutable.js is [MIT-licensed](/node_modules/immutable/LICENSE). ### Thanks [Phil Bagwell](https://www.youtube.com/watch?v=K2NYwP90bNs), for his inspiration and research in persistent data structures. [Hugh Jackson](https://github.com/hughfdjackson/), for providing the npm package name. If you&apos;re looking for his unsupported package, see [this repository](https://github.com/hughfdjackson/immutable).">


<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://localhost:4000/"/>





  <title>Immutable collections for JavaScript</title>
  
















</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yueran's Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<div id="posts" class="posts-expand">
<header class="post-header">

	<h1 class="post-title" itemprop="name headline">Immutable collections for JavaScript</h1>



</header>

  
  
    <h1 id="immutable-collections-for-javascript">Immutable collections for JavaScript</h1>

<p><a href="https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml?query=branch%3Amain"><img src="https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml/badge.svg?branch=main" alt="Build Status" /></a> <a href="https://immutable-js.slack.com">Chat on slack</a></p>

<p><a href="https://immutable-js.com">Read the docs</a> and eat your vegetables.</p>

<p>Docs are automatically generated from <a href="https://github.com/immutable-js/immutable-js/blob/main/README.md">README.md</a> and <a href="https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts">immutable.d.ts</a>.
Please contribute! Also, don’t miss the <a href="https://github.com/immutable-js/immutable-js/wiki">wiki</a> which contains articles on
additional specific topics. Can’t find something? Open an <a href="https://github.com/immutable-js/immutable-js/issues">issue</a>.</p>

<p><strong>Table of contents:</strong></p>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#getting-started">Getting started</a></li>
  <li><a href="#the-case-for-immutability">The case for Immutability</a></li>
  <li><a href="#javaScript-first-api">JavaScript-first API</a></li>
  <li><a href="#nested-structures">Nested Structures</a></li>
  <li><a href="#equality-treats-collections-as-values">Equality treats Collections as Values</a></li>
  <li><a href="#batching-mutations">Batching Mutations</a></li>
  <li><a href="#lazy-seq">Lazy Seq</a></li>
  <li><a href="#additional-tools-and-resources">Additional Tools and Resources</a></li>
  <li><a href="#contributing">Contributing</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p><a href="https://en.wikipedia.org/wiki/Immutable_object">Immutable</a> data cannot be changed once created, leading to much simpler
application development, no defensive copying, and enabling advanced memoization
and change detection techniques with simple logic. <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">Persistent</a> data presents
a mutative API which does not update the data in-place, but instead always
yields new updated data.</p>

<p>Immutable.js provides many Persistent Immutable data structures including:
<code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Stack</code>, <code class="language-plaintext highlighter-rouge">Map</code>, <code class="language-plaintext highlighter-rouge">OrderedMap</code>, <code class="language-plaintext highlighter-rouge">Set</code>, <code class="language-plaintext highlighter-rouge">OrderedSet</code> and <code class="language-plaintext highlighter-rouge">Record</code>.</p>

<p>These data structures are highly efficient on modern JavaScript VMs by using
structural sharing via <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">hash maps tries</a> and <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">vector tries</a> as popularized
by Clojure and Scala, minimizing the need to copy or cache data.</p>

<p>Immutable.js also provides a lazy <code class="language-plaintext highlighter-rouge">Seq</code>, allowing efficient
chaining of collection methods like <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code> without creating
intermediate representations. Create some <code class="language-plaintext highlighter-rouge">Seq</code> with <code class="language-plaintext highlighter-rouge">Range</code> and <code class="language-plaintext highlighter-rouge">Repeat</code>.</p>

<p>Want to hear more? Watch the presentation about Immutable.js:</p>

<p><a href="https://youtu.be/I7IdS-PbEgI"><img src="website/public/Immutable-Data-and-React-YouTube.png" alt="Immutable Data and React" /></a></p>

<h2 id="getting-started">Getting started</h2>

<p>Install <code class="language-plaintext highlighter-rouge">immutable</code> using npm.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>immutable
</code></pre></div></div>

<p>Or install using yarn.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn add immutable
</code></pre></div></div>

<p>Then require it into any module.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> vs. </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">map2</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 2 vs. 50</span>
</code></pre></div></div>

<h3 id="browser">Browser</h3>

<p>Immutable.js has no dependencies, which makes it predictable to include in a Browser.</p>

<p>It’s highly recommended to use a module bundler like <a href="https://webpack.github.io/">webpack</a>,
<a href="https://rollupjs.org/">rollup</a>, or
<a href="https://browserify.org/">browserify</a>. The <code class="language-plaintext highlighter-rouge">immutable</code> npm module works
without any additional consideration. All examples throughout the documentation
will assume use of this kind of tool.</p>

<p>Alternatively, Immutable.js may be directly included as a script tag. Download
or link to a CDN such as <a href="https://cdnjs.com/libraries/immutable">CDNJS</a>
or <a href="https://www.jsdelivr.com/package/npm/immutable">jsDelivr</a>.</p>

<p>Use a script tag to directly add <code class="language-plaintext highlighter-rouge">Immutable</code> to the global scope:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"immutable.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script&gt;</span>
  <span class="kd">var</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
  <span class="kd">var</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
  <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 2</span>
  <span class="nx">map2</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 50</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Or use an AMD-style loader (such as <a href="https://requirejs.org/">RequireJS</a>):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">require</span><span class="p">([</span><span class="dl">'</span><span class="s1">./immutable.min.js</span><span class="dl">'</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">Immutable</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
  <span class="kd">var</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
  <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 2</span>
  <span class="nx">map2</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 50</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="flow--typescript">Flow &amp; TypeScript</h3>

<p>Use these Immutable collections and sequences as you would use native
collections in your <a href="https://flowtype.org/">Flowtype</a> or <a href="https://typescriptlang.org">TypeScript</a> programs while still taking
advantage of type generics, error detection, and auto-complete in your IDE.</p>

<p>Installing <code class="language-plaintext highlighter-rouge">immutable</code> via npm brings with it type definitions for Flow (v0.55.0 or higher)
and TypeScript (v2.1.0 or higher), so you shouldn’t need to do anything at all!</p>

<h4 id="using-typescript-with-immutablejs-v4">Using TypeScript with Immutable.js v4</h4>

<p>Immutable.js type definitions embrace ES2015. While Immutable.js itself supports
legacy browsers and environments, its type definitions require TypeScript’s 2015
lib. Include either <code class="language-plaintext highlighter-rouge">"target": "es2015"</code> or <code class="language-plaintext highlighter-rouge">"lib": "es2015"</code> in your
<code class="language-plaintext highlighter-rouge">tsconfig.json</code>, or provide <code class="language-plaintext highlighter-rouge">--target es2015</code> or <code class="language-plaintext highlighter-rouge">--lib es2015</code> to the
<code class="language-plaintext highlighter-rouge">tsc</code> command.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> vs. </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">map2</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 2 vs. 50</span>
</code></pre></div></div>

<h4 id="using-typescript-with-immutablejs-v3-and-earlier">Using TypeScript with Immutable.js v3 and earlier:</h4>

<p>Previous versions of Immutable.js include a reference file which you can include
via relative path to the type definitions at the top of your file.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///&lt;reference path='./node_modules/immutable/dist/immutable.d.ts'/&gt;</span>
<span class="k">import</span> <span class="nx">Immutable</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">map1</span><span class="p">:</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nb">Map</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="nx">number</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nx">map1</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">var</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 2</span>
<span class="nx">map2</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 50</span>
</code></pre></div></div>

<h2 id="the-case-for-immutability">The case for Immutability</h2>

<p>Much of what makes application development difficult is tracking mutation and
maintaining state. Developing with immutable data encourages you to think
differently about how data flows through your application.</p>

<p>Subscribing to data events throughout your application creates a huge overhead of
book-keeping which can hurt performance, sometimes dramatically, and creates
opportunities for areas of your application to get out of sync with each other
due to easy to make programmer error. Since immutable data never changes,
subscribing to changes throughout the model is a dead-end and new data can only
ever be passed from above.</p>

<p>This model of data flow aligns well with the architecture of <a href="https://reactjs.org/">React</a>
and especially well with an application designed using the ideas of <a href="https://facebook.github.io/flux/docs/in-depth-overview/">Flux</a>.</p>

<p>When data is passed from above rather than being subscribed to, and you’re only
interested in doing work when something has changed, you can use equality.</p>

<p>Immutable collections should be treated as <em>values</em> rather than <em>objects</em>. While
objects represent some thing which could change over time, a value represents
the state of that thing at a particular instance of time. This principle is most
important to understanding the appropriate use of immutable data. In order to
treat Immutable.js collections as values, it’s important to use the
<code class="language-plaintext highlighter-rouge">Immutable.is()</code> function or <code class="language-plaintext highlighter-rouge">.equals()</code> method to determine <em>value equality</em>
instead of the <code class="language-plaintext highlighter-rouge">===</code> operator which determines object <em>reference identity</em>.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="nx">map1</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">map2</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">map1</span> <span class="o">===</span> <span class="nx">map2</span><span class="p">;</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>Note: As a performance optimization Immutable.js attempts to return the existing
collection when an operation would result in an identical collection, allowing
for using <code class="language-plaintext highlighter-rouge">===</code> reference equality to determine if something definitely has not
changed. This can be extremely useful when used within a memoization function
which would prefer to re-run the function if a deeper equality check could
potentially be more costly. The <code class="language-plaintext highlighter-rouge">===</code> equality check is also used internally by
<code class="language-plaintext highlighter-rouge">Immutable.is</code> and <code class="language-plaintext highlighter-rouge">.equals()</code> as a performance optimization.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Set to same value</span>
<span class="nx">map1</span> <span class="o">===</span> <span class="nx">map2</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>If an object is immutable, it can be “copied” simply by making another reference
to it instead of copying the entire object. Because a reference is much smaller
than the object itself, this results in memory savings and a potential boost in
execution speed for programs which rely on copies (such as an undo-stack).</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">mapCopy</span> <span class="o">=</span> <span class="nx">map</span><span class="p">;</span> <span class="c1">// Look, "copies" are free!</span>
</code></pre></div></div>

<h2 id="javascript-first-api">JavaScript-first API</h2>

<p>While Immutable.js is inspired by Clojure, Scala, Haskell and other functional
programming environments, it’s designed to bring these powerful concepts to
JavaScript, and therefore has an Object-Oriented API that closely mirrors that
of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla">ES2015</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>.</p>

<p>The difference for the immutable collections is that methods which would mutate
the collection, like <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">set</code>, <code class="language-plaintext highlighter-rouge">unshift</code> or <code class="language-plaintext highlighter-rouge">splice</code>, instead return a new
immutable collection. Methods which return new arrays, like <code class="language-plaintext highlighter-rouge">slice</code> or <code class="language-plaintext highlighter-rouge">concat</code>,
instead return new immutable collections.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">List</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">list1</span> <span class="o">=</span> <span class="nx">List</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>
<span class="kd">const</span> <span class="nx">list2</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">list3</span> <span class="o">=</span> <span class="nx">list2</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">list4</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">list2</span><span class="p">,</span> <span class="nx">list3</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">list1</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">list2</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">list3</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">list4</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">list4</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Almost all of the methods on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a> will be found in similar form on
<code class="language-plaintext highlighter-rouge">Immutable.List</code>, those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> found on <code class="language-plaintext highlighter-rouge">Immutable.Map</code>, and those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>
found on <code class="language-plaintext highlighter-rouge">Immutable.Set</code>, including collection operations like <code class="language-plaintext highlighter-rouge">forEach()</code>
and <code class="language-plaintext highlighter-rouge">map()</code>.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">alpha</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">d</span><span class="p">:</span> <span class="mi">4</span> <span class="p">});</span>
<span class="nx">alpha</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">k</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()).</span><span class="nx">join</span><span class="p">();</span>
<span class="c1">// 'A,B,C,D'</span>
</code></pre></div></div>

<h3 id="convert-from-raw-javascript-objects-and-arrays">Convert from raw JavaScript objects and arrays.</h3>

<p>Designed to inter-operate with your existing JavaScript, Immutable.js
accepts plain JavaScript Arrays and Objects anywhere a method expects a
<code class="language-plaintext highlighter-rouge">Collection</code>.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span><span class="p">,</span> <span class="nx">List</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">d</span><span class="p">:</span> <span class="mi">4</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">c</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">a</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="na">t</span><span class="p">:</span> <span class="mi">30</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">d</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="na">o</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="na">g</span><span class="p">:</span> <span class="mi">300</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">map3</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="nx">merge</span><span class="p">(</span><span class="nx">map2</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
<span class="c1">// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }</span>
<span class="kd">const</span> <span class="nx">list1</span> <span class="o">=</span> <span class="nx">List</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="kd">const</span> <span class="nx">list2</span> <span class="o">=</span> <span class="nx">List</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]);</span>
<span class="kd">const</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">list3</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">list2</span><span class="p">,</span> <span class="nx">array</span><span class="p">);</span>
<span class="c1">// List [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span>
</code></pre></div></div>

<p>This is possible because Immutable.js can treat any JavaScript Array or Object
as a Collection. You can take advantage of this in order to get sophisticated
collection methods on JavaScript Objects, which otherwise have a very sparse
native API. Because Seq evaluates lazily and does not cache intermediate
results, these operations can be extremely efficient.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">Seq</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="nx">Seq</span><span class="p">(</span><span class="nx">myObject</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">toObject</span><span class="p">();</span>
<span class="c1">// { a: 1, b: 4, c: 9 }</span>
</code></pre></div></div>

<p>Keep in mind, when using JS objects to construct Immutable Maps, that
JavaScript Object properties are always strings, even if written in a quote-less
shorthand, while Immutable Maps accept keys of any type.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">fromJS</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">one</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// [ "1" ]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">],</span> <span class="nx">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// "one", "one"</span>

<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">fromJS</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">),</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// "one", undefined</span>
</code></pre></div></div>

<p>Property access for JavaScript Objects first converts the key to a string, but
since Immutable Map keys can be of any type the argument to <code class="language-plaintext highlighter-rouge">get()</code> is
not altered.</p>

<h3 id="converts-back-to-raw-javascript-objects">Converts back to raw JavaScript objects.</h3>

<p>All Immutable.js Collections can be converted to plain JavaScript Arrays and
Objects shallowly with <code class="language-plaintext highlighter-rouge">toArray()</code> and <code class="language-plaintext highlighter-rouge">toObject()</code> or deeply with <code class="language-plaintext highlighter-rouge">toJS()</code>.
All Immutable Collections also implement <code class="language-plaintext highlighter-rouge">toJSON()</code> allowing them to be passed
to <code class="language-plaintext highlighter-rouge">JSON.stringify</code> directly. They also respect the custom <code class="language-plaintext highlighter-rouge">toJSON()</code> methods of
nested objects.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span><span class="p">,</span> <span class="nx">List</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">deep</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="nx">List</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span> <span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">deep</span><span class="p">.</span><span class="nx">toObject</span><span class="p">());</span> <span class="c1">// { a: 1, b: 2, c: List [ 3, 4, 5 ] }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">deep</span><span class="p">.</span><span class="nx">toArray</span><span class="p">());</span> <span class="c1">// [ 1, 2, List [ 3, 4, 5 ] ]</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">deep</span><span class="p">.</span><span class="nx">toJS</span><span class="p">());</span> <span class="c1">// { a: 1, b: 2, c: [ 3, 4, 5 ] }</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">deep</span><span class="p">);</span> <span class="c1">// '{"a":1,"b":2,"c":[3,4,5]}'</span>
</code></pre></div></div>

<h3 id="embraces-es2015">Embraces ES2015</h3>

<p>Immutable.js supports all JavaScript environments, including legacy
browsers (even IE11). However it also takes advantage of features added to
JavaScript in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla">ES2015</a>, the latest standard version of JavaScript, including
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">Iterators</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow Functions</a>, <a href="https://wiki.ecmascript.org/doku.php?id=strawman:maximally_minimal_classes">Classes</a>, and <a href="https://www.2ality.com/2014/09/es6-modules-final.html">Modules</a>. It’s inspired
by the native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a> collections added to ES2015.</p>

<p>All examples in the Documentation are presented in ES2015. To run in all
browsers, they need to be translated to ES5.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES2015</span>
<span class="kd">const</span> <span class="nx">mapped</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
<span class="c1">// ES5</span>
<span class="kd">var</span> <span class="nx">mapped</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>All Immutable.js collections are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">Iterable</a>, which allows them to be
used anywhere an Iterable is expected, such as when spreading into an Array.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">List</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">aList</span> <span class="o">=</span> <span class="nx">List</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="kd">const</span> <span class="nx">anArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">...</span><span class="nx">aList</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span> <span class="c1">// [ 0, 1, 2, 3, 4, 5 ]</span>
</code></pre></div></div>

<p>Note: A Collection is always iterated in the same order, however that order may
not always be well defined, as is the case for the <code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">Set</code>.</p>

<h2 id="nested-structures">Nested Structures</h2>

<p>The collections in Immutable.js are intended to be nested, allowing for deep
trees of data, similar to JSON.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">fromJS</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">nested</span> <span class="o">=</span> <span class="nx">fromJS</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="p">{</span> <span class="na">c</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="p">}</span> <span class="p">}</span> <span class="p">});</span>
<span class="c1">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }</span>
</code></pre></div></div>

<p>A few power-tools allow for reading and operating on nested data. The
most useful are <code class="language-plaintext highlighter-rouge">mergeDeep</code>, <code class="language-plaintext highlighter-rouge">getIn</code>, <code class="language-plaintext highlighter-rouge">setIn</code>, and <code class="language-plaintext highlighter-rouge">updateIn</code>, found on <code class="language-plaintext highlighter-rouge">List</code>,
<code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">OrderedMap</code>.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">fromJS</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">nested</span> <span class="o">=</span> <span class="nx">fromJS</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="p">{</span> <span class="na">c</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="p">}</span> <span class="p">}</span> <span class="p">});</span>

<span class="kd">const</span> <span class="nx">nested2</span> <span class="o">=</span> <span class="nx">nested</span><span class="p">.</span><span class="nx">mergeDeep</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="p">{</span> <span class="na">d</span><span class="p">:</span> <span class="mi">6</span> <span class="p">}</span> <span class="p">}</span> <span class="p">});</span>
<span class="c1">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">nested2</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">]));</span> <span class="c1">// 6</span>

<span class="kd">const</span> <span class="nx">nested3</span> <span class="o">=</span> <span class="nx">nested2</span><span class="p">.</span><span class="nx">updateIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">],</span> <span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">nested3</span><span class="p">);</span>
<span class="c1">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }</span>

<span class="kd">const</span> <span class="nx">nested4</span> <span class="o">=</span> <span class="nx">nested3</span><span class="p">.</span><span class="nx">updateIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">],</span> <span class="nx">list</span> <span class="o">=&gt;</span> <span class="nx">list</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
<span class="c1">// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }</span>
</code></pre></div></div>

<h2 id="equality-treats-collections-as-values">Equality treats Collections as Values</h2>

<p>Immutable.js collections are treated as pure data <em>values</em>. Two immutable
collections are considered <em>value equal</em> (via <code class="language-plaintext highlighter-rouge">.equals()</code> or <code class="language-plaintext highlighter-rouge">is()</code>) if they
represent the same collection of values. This differs from JavaScript’s typical
<em>reference equal</em> (via <code class="language-plaintext highlighter-rouge">===</code> or <code class="language-plaintext highlighter-rouge">==</code>) for Objects and Arrays which only
determines if two variables represent references to the same object instance.</p>

<p>Consider the example below where two identical <code class="language-plaintext highlighter-rouge">Map</code> instances are not
<em>reference equal</em> but are <em>value equal</em>.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// First consider:</span>
<span class="kd">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="nx">obj1</span> <span class="o">!==</span> <span class="nx">obj2</span><span class="p">;</span> <span class="c1">// two different instances are always not equal with ===</span>

<span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span><span class="p">,</span> <span class="nx">is</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="nx">map1</span> <span class="o">!==</span> <span class="nx">map2</span><span class="p">;</span> <span class="c1">// two different instances are not reference-equal</span>
<span class="nx">map1</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">map2</span><span class="p">);</span> <span class="c1">// but are value-equal if they have the same values</span>
<span class="nx">is</span><span class="p">(</span><span class="nx">map1</span><span class="p">,</span> <span class="nx">map2</span><span class="p">);</span> <span class="c1">// alternatively can use the is() function</span>
</code></pre></div></div>

<p>Value equality allows Immutable.js collections to be used as keys in Maps or
values in Sets, and retrieved with different but equivalent collections:</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span><span class="p">,</span> <span class="nb">Set</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="kd">set</span> <span class="o">=</span> <span class="nb">Set</span><span class="p">().</span><span class="nx">add</span><span class="p">(</span><span class="nx">map1</span><span class="p">);</span>
<span class="kd">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">map2</span><span class="p">);</span> <span class="c1">// true because these are value-equal</span>
</code></pre></div></div>

<p>Note: <code class="language-plaintext highlighter-rouge">is()</code> uses the same measure of equality as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a> for scalar
strings and numbers, but uses value equality for Immutable collections,
determining if both are immutable and all keys and values are equal
using the same measure of equality.</p>

<h4 id="performance-tradeoffs">Performance tradeoffs</h4>

<p>While value equality is useful in many circumstances, it has different
performance characteristics than reference equality. Understanding these
tradeoffs may help you decide which to use in each case, especially when used
to memoize some operation.</p>

<p>When comparing two collections, value equality may require considering every
item in each collection, on an <code class="language-plaintext highlighter-rouge">O(N)</code> time complexity. For large collections of
values, this could become a costly operation. Though if the two are not equal
and hardly similar, the inequality is determined very quickly. In contrast, when
comparing two collections with reference equality, only the initial references
to memory need to be compared which is not based on the size of the collections,
which has an <code class="language-plaintext highlighter-rouge">O(1)</code> time complexity. Checking reference equality is always very
fast, however just because two collections are not reference-equal does not rule
out the possibility that they may be value-equal.</p>

<h4 id="return-self-on-no-op-optimization">Return self on no-op optimization</h4>

<p>When possible, Immutable.js avoids creating new objects for updates where no
change in <em>value</em> occurred, to allow for efficient <em>reference equality</em> checking
to quickly determine if no change occurred.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">originalMap</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">updatedMap</span> <span class="o">=</span> <span class="nx">originalMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">updatedMap</span> <span class="o">===</span> <span class="nx">originalMap</span><span class="p">;</span> <span class="c1">// No-op .set() returned the original reference.</span>
</code></pre></div></div>

<p>However updates which do result in a change will return a new reference. Each
of these operations occur independently, so two similar updates will not return
the same reference:</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">originalMap</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">updatedMap</span> <span class="o">=</span> <span class="nx">originalMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="c1">// New instance, leaving the original immutable.</span>
<span class="nx">updatedMap</span> <span class="o">!==</span> <span class="nx">originalMap</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">anotherUpdatedMap</span> <span class="o">=</span> <span class="nx">originalMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="c1">// Despite both the results of the same operation, each created a new reference.</span>
<span class="nx">anotherUpdatedMap</span> <span class="o">!==</span> <span class="nx">updatedMap</span><span class="p">;</span>
<span class="c1">// However the two are value equal.</span>
<span class="nx">anotherUpdatedMap</span><span class="p">.</span><span class="nx">equals</span><span class="p">(</span><span class="nx">updatedMap</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="batching-mutations">Batching Mutations</h2>

<blockquote>
  <p>If a tree falls in the woods, does it make a sound?</p>

  <p>If a pure function mutates some local data in order to produce an immutable
return value, is that ok?</p>

  <p>— Rich Hickey, Clojure</p>
</blockquote>

<p>Applying a mutation to create a new immutable object results in some overhead,
which can add up to a minor performance penalty. If you need to apply a series
of mutations locally before returning, Immutable.js gives you the ability to
create a temporary mutable (transient) copy of a collection and apply a batch of
mutations in a performant manner by using <code class="language-plaintext highlighter-rouge">withMutations</code>. In fact, this is
exactly how Immutable.js applies complex mutations itself.</p>

<p>As an example, building <code class="language-plaintext highlighter-rouge">list2</code> results in the creation of 1, not 3, new
immutable Lists.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">List</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">list1</span> <span class="o">=</span> <span class="nx">List</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
<span class="kd">const</span> <span class="nx">list2</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">withMutations</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">list</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">list1</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">list2</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</code></pre></div></div>

<p>Note: Immutable.js also provides <code class="language-plaintext highlighter-rouge">asMutable</code> and <code class="language-plaintext highlighter-rouge">asImmutable</code>, but only
encourages their use when <code class="language-plaintext highlighter-rouge">withMutations</code> will not suffice. Use caution to not
return a mutable copy, which could result in undesired behavior.</p>

<p><em>Important!</em>: Only a select few methods can be used in <code class="language-plaintext highlighter-rouge">withMutations</code> including
<code class="language-plaintext highlighter-rouge">set</code>, <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code>. These methods can be applied directly against a
persistent data-structure where other methods like <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">sort</code>,
and <code class="language-plaintext highlighter-rouge">splice</code> will always return new immutable data-structures and never mutate
a mutable collection.</p>

<h2 id="lazy-seq">Lazy Seq</h2>

<p><code class="language-plaintext highlighter-rouge">Seq</code> describes a lazy operation, allowing them to efficiently chain
use of all the higher-order collection methods (such as <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code>)
by not creating intermediate collections.</p>

<p><strong>Seq is immutable</strong> — Once a Seq is created, it cannot be
changed, appended to, rearranged or otherwise modified. Instead, any mutative
method called on a <code class="language-plaintext highlighter-rouge">Seq</code> will return a new <code class="language-plaintext highlighter-rouge">Seq</code>.</p>

<p><strong>Seq is lazy</strong> — <code class="language-plaintext highlighter-rouge">Seq</code> does as little work as necessary to respond to any
method call. Values are often created during iteration, including implicit
iteration when reducing or converting to a concrete data structure such as
a <code class="language-plaintext highlighter-rouge">List</code> or JavaScript <code class="language-plaintext highlighter-rouge">Array</code>.</p>

<p>For example, the following performs no work, because the resulting
<code class="language-plaintext highlighter-rouge">Seq</code>’s values are never iterated:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">Seq</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">oddSquares</span> <span class="o">=</span> <span class="nx">Seq</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
</code></pre></div></div>

<p>Once the <code class="language-plaintext highlighter-rouge">Seq</code> is used, it performs only the work necessary. In this
example, no intermediate arrays are ever created, filter is called three
times, and map is only called once:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">oddSquares</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 9</span>
</code></pre></div></div>

<p>Any collection can be converted to a lazy Seq with <code class="language-plaintext highlighter-rouge">Seq()</code>.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nb">Map</span><span class="p">,</span> <span class="nx">Seq</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nb">Map</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span> <span class="p">});</span>
<span class="kd">const</span> <span class="nx">lazySeq</span> <span class="o">=</span> <span class="nx">Seq</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Seq</code> allows for the efficient chaining of operations, allowing for the
expression of logic that can otherwise be very tedious:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">lazySeq</span>
  <span class="p">.</span><span class="nx">flip</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">key</span> <span class="o">=&gt;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">flip</span><span class="p">();</span>
<span class="c1">// Seq { A: 1, B: 2, C: 3 }</span>
</code></pre></div></div>

<p>As well as expressing logic that would otherwise seem memory or time
limited, for example <code class="language-plaintext highlighter-rouge">Range</code> is a special kind of Lazy sequence.</p>

<!-- runkit:activate -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">Range</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">immutable</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">skip</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="nx">n</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">r</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span> <span class="o">*</span> <span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// 1006008</span>
</code></pre></div></div>

<h2 id="additional-tools-and-resources">Additional Tools and Resources</h2>

<ul>
  <li><a href="https://github.com/jameshopkins/atom-store/">Atom-store</a>
    <ul>
      <li>A Clojure-inspired atom implementation in Javascript with configurability
for external persistance.</li>
    </ul>
  </li>
  <li><a href="https://github.com/astorije/chai-immutable">Chai Immutable</a>
    <ul>
      <li>If you are using the <a href="https://chaijs.com/">Chai Assertion Library</a>, this
provides a set of assertions to use against Immutable.js collections.</li>
    </ul>
  </li>
  <li><a href="https://github.com/fantasyland/fantasy-land">Fantasy-land</a>
    <ul>
      <li>Specification for interoperability of common algebraic structures in JavaScript.</li>
    </ul>
  </li>
  <li><a href="https://github.com/pelotom/immutagen">Immutagen</a>
    <ul>
      <li>A library for simulating immutable generators in JavaScript.</li>
    </ul>
  </li>
  <li><a href="https://github.com/redbadger/immutable-cursor">Immutable-cursor</a>
    <ul>
      <li>Immutable cursors incorporating the Immutable.js interface over
Clojure-inspired atom.</li>
    </ul>
  </li>
  <li><a href="https://github.com/DrBoolean/immutable-ext">Immutable-ext</a>
    <ul>
      <li>Fantasyland extensions for immutablejs</li>
    </ul>
  </li>
  <li><a href="https://github.com/madeinfree/immutable-js-tools">Immutable-js-tools</a>
    <ul>
      <li>Util tools for immutable.js</li>
    </ul>
  </li>
  <li><a href="https://github.com/gajus/redux-immutable">Immutable-Redux</a>
    <ul>
      <li>redux-immutable is used to create an equivalent function of Redux
combineReducers that works with Immutable.js state.</li>
    </ul>
  </li>
  <li><a href="https://github.com/lukasbuenger/immutable-treeutils">Immutable-Treeutils</a>
    <ul>
      <li>Functional tree traversal helpers for ImmutableJS data structures.</li>
    </ul>
  </li>
  <li><a href="https://github.com/ericelliott/irecord">Irecord</a>
    <ul>
      <li>An immutable store that exposes an RxJS observable. Great for React.</li>
    </ul>
  </li>
  <li><a href="https://github.com/brianneisler/mudash">Mudash</a>
    <ul>
      <li>Lodash wrapper providing Immutable.JS support.</li>
    </ul>
  </li>
  <li><a href="https://github.com/HurricaneJames/react-immutable-proptypes">React-Immutable-PropTypes</a>
    <ul>
      <li>PropType validators that work with Immutable.js.</li>
    </ul>
  </li>
  <li><a href="https://github.com/indexiatech/redux-immutablejs">Redux-Immutablejs</a>
    <ul>
      <li>Redux Immutable facilities.</li>
    </ul>
  </li>
  <li><a href="https://github.com/yamalight/rxstate">Rxstate</a>
    <ul>
      <li>Simple opinionated state management library based on RxJS and Immutable.js.</li>
    </ul>
  </li>
  <li><a href="https://github.com/glenjamin/transit-immutable-js">Transit-Immutable-js</a>
    <ul>
      <li>Transit serialisation for Immutable.js.</li>
      <li>See also: <a href="https://github.com/cognitect/transit-js">Transit-js</a></li>
    </ul>
  </li>
</ul>

<p>Have an additional tool designed to work with Immutable.js?
Submit a PR to add it to this list in alphabetical order.</p>

<h2 id="contributing">Contributing</h2>

<p>Use <a href="https://github.com/immutable-js/immutable-js/issues">Github issues</a> for requests.</p>

<p>We actively welcome pull requests, learn how to <a href="https://github.com/immutable-js/immutable-js/blob/main/.github/CONTRIBUTING.md">contribute</a>.</p>

<p>Immutable.js is maintained within the <a href="https://www.contributor-covenant.org/version/2/0/code_of_conduct/">Contributor Covenant’s Code of Conduct</a>.</p>

<h3 id="changelog">Changelog</h3>

<p>Changes are tracked as <a href="https://github.com/immutable-js/immutable-js/releases">Github releases</a>.</p>

<h3 id="license">License</h3>

<p>Immutable.js is <a href="/node_modules/immutable/LICENSE">MIT-licensed</a>.</p>

<h3 id="thanks">Thanks</h3>

<p><a href="https://www.youtube.com/watch?v=K2NYwP90bNs">Phil Bagwell</a>, for his inspiration
and research in persistent data structures.</p>

<p><a href="https://github.com/hughfdjackson/">Hugh Jackson</a>, for providing the npm package
name. If you’re looking for his unsupported package, see <a href="https://github.com/hughfdjackson/immutable">this repository</a>.</p>

  
</div>


          </div>
          


          

        </div>
        
          

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/assets/images/avatar.jpg"
               alt="Yueran" />
          <p class="site-author-name" itemprop="name">Yueran</p>
           
              <p class="site-description motion-element" itemprop="description">Shoot for the moon. Even if you miss, you'll land among the stars.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          

        </nav>

        
        
        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              
              
              <span class="links-of-author-item">
                <a href="https://github.com/Yueran-Yu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              
              
              <span class="links-of-author-item">
                <a href="https://weibo.com/2100931767/" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>

        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yueran</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://jekyllrb.com">Jekyll</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/simpleyyt/jekyll-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





















  
   
  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/assets/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/assets/js/src/motion.js?v=5.1.1"></script>



  
  

  <script type="text/javascript" src="/assets/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/assets/js/src/post-details.js?v=5.1.1"></script>


  


  <script type="text/javascript" src="/assets/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Yueran.disqus.com/count.js" async></script>
    

    

  




	





  





  




  





  


  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  


  

  

  

</body>
</html>

